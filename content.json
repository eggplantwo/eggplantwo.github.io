{"meta":{"title":"가지가지하는 블로그","subtitle":"가지가지하는 블로그","description":"php, javascript, front, devlop","author":"jaepil Jung","url":"http://eggplantwo.github.io"},"pages":[],"posts":[{"title":"composer","slug":"composer","date":"2017-04-21T07:10:04.000Z","updated":"2017-04-21T07:09:02.258Z","comments":true,"path":"2017/04/21/composer/","link":"","permalink":"http://eggplantwo.github.io/2017/04/21/composer/","excerpt":"","text":"컴포저composer 는 php 를 개발하는데 있어서 패키지간의 의존성을 관리하는 의존성 관리자입니다.node.js 의 npm, ruby의 bundle과 같은 역할을 수행합니다. 사용 이점 컴포넌트 관리 자동화 개발/운영 동일한 의존성을 사용, 버전 불일치 등의 문제 발생을 피할 수 있다. 오토로드 지원 컴포저 컴포넌트(vendor)는 버전관리 되지 않아 코드공간을 줄일 수 있다. 패키지의 검색composer 를 통해서 설치할 수 있는 수많은 패키지들을 packagist를 에서 키워드나 패키지명, 벤더의 이름을 기반으로 검색하여 원하는 패키지를 손쉽게 찾을 수 있다. 1. 로컬 컴포넌트 레지스트리 둘러보기123456789101112131415161718192021222324252627282930313233\"require\": &#123; // 의존 컴포넌트 \"php\": \"&gt;=5.6.4\", \"laravel/framework\": \"5.3.*\", \"guzzlehttp/guzzle\": \"5.3.*\",&#125;\"require-dev\": &#123; // 개발시에만 필요한 컴포넌트 목록&#125;``` ## 2. 명령어```shell- composer require 벤더/페키지선언 설치 한번에 하기- composer require 벤더/패키지 --dev - 개발 의존성 설치- composer require 벤더/패키지 --no-dev - 운영서버에서 개발 의존성 - composer install - 프로젝트가 의존하는 컴포넌트 버전을 그래도 설치할 때 - composer.lock에 정의된 컴포넌트 버전을 그대로 설치 할때- composer update - 설치된 컴포넌트 업데이트- pomposert.lock 3. 문제해결 버전 출돌이 발생했을때 composer.json 파일을 열어 충돌하는 컴포넌트의 버전확인 계속해서 충돌이 발생할때 composer.lock과 vendor를 지우고 재설치 한다.(composer install) 4. 오토로드컴포저는 vendor 디렉터리 아래에 자신이 참조할 데이터베이스를 미리 만들어 놓는다.이 데이터베이스는 클래스 이름과 파일 경로 간 매핑을 담고 있다.vendor/autoload.php 를 이용해 데이터베이스를 메모리로 올린다. composer.json 의 autoload 설정을 통해서도 할 수 있습니다.12345&#123; \"autoload\": &#123; \"psr-4\": &#123;\"Acme\\\\\": \"src/\"&#125; &#125;&#125; 오토로딩은 네임스페이스에 대한 디렉토리 매핑을 정의한다.src 디렉토리는 vendor 디렉토리와 마찬가지로 프로젝트 루트 디렉토리에 존재한다.src/Foo.php 파일은 Acme\\Foo 클래스를 의미 한다. autoload.php 파일을 include 하게 되면 인스턴스를 리턴받을 수 있고, 이를 이용해 추가적인 네임스페이스를 지정할 수도 있다.12$loader = require 'vendor/autoload.php';$loader-&gt;add('Acme\\\\Test\\\\', __DIR__); 4.1 동작 순서public/index.php -&gt; bootstrap/autoload.php -&gt; vendor/autoload.php 4.2 원리어떤 클래스가 동작할 때 다른 클래스를 참조하면, 메모리에 적제된 정보를 이용해 매핑된 파일을 찾아서 자동으로 require를 수행한다. 한글 매뉴얼 Composer-korean-docs","categories":[{"name":"php","slug":"php","permalink":"http://eggplantwo.github.io/categories/php/"}],"tags":[]},{"title":"CSS 트랜지션","slug":"CSS_Transition","date":"2017-04-21T07:04:31.000Z","updated":"2017-04-21T07:03:46.682Z","comments":true,"path":"2017/04/21/CSS_Transition/","link":"","permalink":"http://eggplantwo.github.io/2017/04/21/CSS_Transition/","excerpt":"","text":"CSS 트랜지션과 애니메이션의 기초CSS를 이용한 애니메이션에는 CSS 트랜지션과 CSS 키프레임 애니메이션 두 가지 범주가 있다. CSS 트랜지션은 시작 상태와 종료상태의 두 가지 고유한 상태 간에 값을 보간하는 애니메이션 기법이다. CSS 키프레임 애니메이션은 시작과 종료 외에도 키프레임을 이용해 중간 단계를 제어하는 방법으로 더 복잡한 애니메이션을 만들 수 있게 해준다. CSS 트랜지션css 트랜지션은 tansition 속성을 이용해 제어한다.이 속성은 브라우저가 해당 셀렉터 내의 속성 값을 지정한 시간 동안 보간해 에니메이션 효과를 만들게 한다. 애니메이션을 적용할 요소 속성 이름(예 color 또는 width). 생략하면 애니메이션 가능한 모든 속성이 대상이 된다. 애니메이션 지속 시간 가속 곡선을 제어할 선택적 타이밍 함수 (예 ease-in 및 ease-out) 애니메이션을 시작하기 전 선택적 지연 시간 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html lang=\"kr\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; a&#123; font-family: Helvetica, Arial, sans-serif; text-decoration: none; color:#fff; &#125; .button&#123; padding: 0.75rem 1rem; border-radius:0.3rem; box-shadow:0; background-color: #bbb; &#125; .button:hover&#123; background-color: #e22; box-shadow: 0 4px #900; transition: 0.5s; &#125; body &#123; text-align: center; &#125; @keyframes pulsing-heart &#123; 0% &#123;transform : none;&#125; 50% &#123;transform : scale(1.4);&#125; 100% &#123;transform : none;&#125; &#125; .heart &#123; font-size: 10rem; color: #f00; border : 1px solid red; &#125; .heart:hover&#123; animation : pulsing-heart .5s infinite; transform-origin: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"#\" class=\"button\"&gt;Hover Me!&lt;/a&gt; &lt;dir class=\"heart\"&gt;&amp;hearts;&lt;/dir&gt;&lt;/body&gt;&lt;/html&gt; 키프레임 애니메이션브라우져가 모든 것을 처리하는 트랜지션 기법에 비해 애니메이션 시퀀스의 중간 단계를 훨씬 세부적으로 제어.12345@keyframes pulsing-heart &#123; 0% &#123;transform : none;&#125; 50% &#123;transform : scale(1.4);&#125; 100% &#123;transform : none;&#125;&#125; 프로그래밍 방식으로 CSS 트랜지션과 애니메이션 시작CSS 트랜지션과 애니메이션을 트리거하는 시점을 더 유연하게 제어하려면 자바스크립트를 이용해야 한다.일반적으로 클래스 스와핑 기법을 사용한다. ReactCSSTransitionGroup애니메이션에 포한할 모든 컨포넌트를 래핑하며 컴포넌트 수명주기(예: 마운팅과 언마운팅)와 연관된 특정한 시점에 CSS 애니메이션과 트랜지션을 트리거하는 간단한 요소다.","categories":[{"name":"css","slug":"css","permalink":"http://eggplantwo.github.io/categories/css/"}],"tags":[]},{"title":"함수 패턴","slug":"함수패턴","date":"2017-04-21T07:03:31.000Z","updated":"2017-04-21T07:07:22.523Z","comments":true,"path":"2017/04/21/함수패턴/","link":"","permalink":"http://eggplantwo.github.io/2017/04/21/함수패턴/","excerpt":"","text":"함수함수는 일급 객체이다.함수는 유효범위(scope)를 제공한다. 런타임, 즉 프로그램 실행 중에 동적으로 생성할 수 있다. 변수에 할당할 수 있고, 다름 변수에 참조를 복사할 수 있으며, 확장가능하고, 특별한 경우를 제외하면 삭제가 가능하다. 다른변수의 인자로 전달할 수 있고, 다른 함수의 반환 값이 될 수 있다. 자기 자신의 프로퍼티와 메서드를 가질 수 있다. 콜백 패턴12345678910111213141516171819202122232425262728293031323334353637383940ver findNodes = function (callback) &#123; var i = 10000, nodes = [], found; // 콜백 함수를 호출할 수 있는지 확인한다. if ( typeof callback !== 'function' ) &#123; callback = false; &#125; while (i) &#123; i -= 1; /* 로직 구현 found = node; */ if ( callback ) &#123; callback(found) &#125; nodes.push(found); &#125; return nodes;&#125;var hide = function (nodes) &#123; if ( Object.prototype.toString.call(nodes) === '[object Array]' ) &#123; var i = 0; max = nodes.length; for ( ; i &lt; max; i += 1 ) &#123; nodes[i].style.display = 'none'; &#125; &#125; else &#123; node.style.display = 'none'; &#125;&#125;findNodes( function(node) &#123; node.style.display = 'none';&#125;); 함수 반환하기123456789var setup = function() &#123; alert(1); return function() &#123; alert(2); &#125;&#125;var my = setup(); // alert(1);my(); // alert(2); setup()은 반환된 함수를 감싸고 있기 때문에 클로저를 생산한다.클로저는 반환되는 함수에서는 접근할 수 있지만 코드 외부에서는 접근할 수 없기 때문에, 비공개 데이터 저장을 위해 사용 할 수있다. ex) 카운터 예제1234567891011var setup = function() &#123; var count = 0; return function() &#123; return count += 1; &#125;&#125;var next = setup();next(); // 1next(); // 2next(); // 3 자기 자신을 정의하는 함수함수는 동적으로 정의할 수 있고 변수에 할당할 수 있다.새로운 함수를 만들어 이미 다른 함수를 가지고 있는 변수에 할당한다면, 새로운 함수가 이전 함수를 덮어쓰게 된다.포인터가 새로운 함수를 가리키도록 재사용하는 것이다.본문 내에서도 이런일을 할 수 있는데, 이 경우 함수는 자기 자신을 새로운 구현으로 덮었고 재정의 한다. 123456var scareMe = function() &#123; alert('Boo!'); scareMe = function() &#123; alert(\"Double boo!\"); &#125;;&#125; 이 패턴은 함수가 어떤 초기화 준비 작업을 단 한번만 수행할 경우에 유용하다.(lazy function pattern)재 정의된 함수의 작업랼이 적기 때문에 애플리케이션 성능에 도움이 된다.단점, 함수가 새로운 변수에 할당되면 예상과 달리 자기 자신을 정의하지 않는다. 즉시 실행 함수1234567891011121314// 객체프로퍼티 정의에 사용 (처음에 한번만 값을 계산해 정의하고 계속 사용.)var o = &#123; message : (function() &#123; var who = 'me', what = 'call'; return what + ' ' + who; &#125;()), getMsg : function() &#123; return this.message; &#125;&#125;// o.getMsg(); // call me// o.message; // call me 초기화 시점의 분기123456789101112131415161718192021222324var utils = &#123; addListener : null, removeListener : null&#125;// 구현if ( typeof window.addEventListener === 'function' ) &#123; utils.addListener = function(el, type, fn) &#123; el.addEventListener(type, fn, false); &#125;; utils.removeListener = function(el, type, fn) &#123; el.addEventListener(type, fn, false); &#125;;&#125; else if ( typeof document.attachEvent === 'function' ) &#123; // 구현...&#125; else &#123; utils.addListener = function(el, type, fn) &#123; el['on' + type] = fn; &#125; utils.removeListener = function(el, type, fn) &#123; el['on' + type] = null; &#125;&#125;... 함수 프로퍼티 - 메모이 제이션 패턴12345678910var getId = (function() &#123; var cacheId = &#123;&#125;; return function(id) &#123; if( !cacheId[id] ) &#123; console.log(id); cacheId[id] = document.getElementById(id); &#125; return cacheId[id]; &#125;&#125;)(); 설정 객체 패턴함수의 매개변수를 객체로 받는다.유지보수 용이, 다양한 요구사항에 대응. 123456789var info = &#123; a : '1', b : '2', c : '3' ...&#125;function add(info) &#123;&#125; 커리부분적인 함수 적용123456789var add = function(x, y) &#123; return x + y;&#125;//모든 인자를 적용add.apply(null, [4, 5]); // 9// 인자를 부분 적으로 적용var newadd = add.partialApply(null, [4]);newadd.apply(null, [5]); // 9 자바스크립트는 기본적으로 이렇게 동작하지 않지만 굉장히 동적이기 때문에 이렇게 동작하도록 만들 수 있다.커링 - 함수가 부분적인 적용을 이해하고 처리할 수 있도록 만드는 과정 커링(Curring)수학자 하스켈 커리의 이름에서 따옴. (하스켈 언어와 같은 유래)커링은 함수를 변형하는 과정이다. 123456789101112131415161718// 커링된 add()// 부분적인 인자의 목록을 받는다.function add(x, y) &#123; if ( typeof ㅛ === 'undefined' ) &#123; // 부분적인 적용 return function(y) &#123; return x + y; &#125;; &#125; return x + y; // 전체 인자 적용&#125;// 테슽typeof add; // functionadd(3)(4); // 7// 새로운 함수를 만들어 저장var add2000 = add(2000);add2000(10); // 2010; 범용 커링 함수의 코드 12345678910111213141516171819202122232425262728293031323334353637function schonfinkelize(fn) &#123; console.log(arguments); // 전달받은 매개변수 객체 var slice = Array.prototype.slice, stored_args = slice.call(arguments, 1); console.log(stored_args); // 배욜 1 부터 끝 return function() &#123; console.log(arguments); var new_args = slice.call(arguments), aregs = stored_args.concat(new_args); console.log(aregs); return fn.apply(null, args); &#125;&#125;// 일반함수function add( x, y ) &#123; return x + y;&#125;// 함수를 커링하여 새로운 함수를 얻는다.var newadd = schonfinkelize(add, 5);newadd(4); // 9// 매개변수가 여러개이고, 커링이 여러단계 일때function add(a, b, c, d, e, f) &#123; return a+ b+c+d+e+f;&#125;// 여러개의 인자 사용;schonfinkelize(add, 1, 2, 3)(5, 5); // 16// 2단계 커링var addOne = schonfinkelize(add, 1);addOne(10, 10, 10, 10); // 41var addSix = schonfinkelize(addOne, 2, 3); // addOne : 1단계에서 1값이 커링된 상태.addSix(5, 5); // 16 커링을 사용해야 하는 이유 요약","categories":[{"name":"javascript","slug":"javascript","permalink":"http://eggplantwo.github.io/categories/javascript/"}],"tags":[]},{"title":"코드 재사용 패턴","slug":"코드재사용패턴","date":"2017-04-21T07:03:31.000Z","updated":"2017-04-21T07:07:25.018Z","comments":true,"path":"2017/04/21/코드재사용패턴/","link":"","permalink":"http://eggplantwo.github.io/2017/04/21/코드재사용패턴/","excerpt":"","text":"코드 재사용 패턴 Gof의 충고 ‘클래스 상속보다 객체 합성을 우선시 하라’ 클래스 방식 vs 새로운 방식의 상속 패턴클래스 방식의 상속을 사용할 경우 예상되는 산출물클래스 방식의 상속 패턴 - 기본패턴 가장 기본적인 방법으로 Parent()생성자를 사용해 객체를 생성한 다음, 이 객체를 Child()의 프로토타입에 할당하는것이다. 12345678910function inherit(C, P) &#123; Child.prototype = new Parent();&#125;var p = new Parent();var p = &#123;&#125;;p.__proto__ = Parent.prototype;Parent.apply(p, arguments);//Parent.call(p, arg1, arg2[,arg3...]); 함수가 생성될때 일어나는 일 즉시 함수에 prototype 키를 만들고 오브젝트를 할당한다. prototype 오브젝트 안에는 constructor라는 키가 잡히고 함수 자신의 참조가 들어간다. // 함수가 생성되면function Alert(); // 1. 즉시 prototype이라는 이름의 키에 오브젝트가 생성되고Alert.prototype = {}; 이 과정은 절대로 일어나고 C 수준의 파서에서 관리하는 영역이다. 따라서 prototype은 함수 객체를 만들면 함수 객체에 정의되는 특별한 키이고, 그 키에 할당된 객체는 특별히 constructor 키가 언제나 정의 되어 있다. prototype을 new 와 함께 사용하기 new 가 어떻게 작동되는지 살펴봅시다. var a = new Alert( ‘test’ ); // 1a = {}; // 2a.proto = Alert.prototype; // 3temp = Alert.apply( a, arguments );if( typeof temp == ‘object’ || typeof temp == ‘function’ ) a = temp; 위의 2번 단계를 살펴보면 new 구문을 통해 Alert.prototype 에 대한 참조가 a 에게 proto 로 잡혀있음을 알 수 있습니다.이것만 집중적으로 보려합니다. 함수의 정의부터 다시 복습해보면 123456789101112131415161718192021function Alert($msg) &#123; this._msg = $msg;&#125;Alert.prototype.action = function() &#123; alert(this._msg);&#125;;var a = new Alert('test');a.__proto__ = Alert.prototype; //2// 이 코드를 새삼 다시 보면 아래와 같은 결론에 도달한다.a.__proto__ == Alert.prototype;a.__proto__.action == Alert.prototype.action;참조가 같으니 Alert 의 프로토타입에 정의된 모든 속성은 전부 a.proto 도 참조할 수 있게 된다. 특히 constructor도 참조된다.new 하면 constructor가 참조되는 비밀이 풀렸다.a.__proto__.constructor = Alert.prototype.constructor = Alert;a.action // 이런 코드가 가능한 이유 proto 가 작동하는 방식프로토타입 체인프로토타입 체인 만들기프로토타입 시스템 전반을 이용한 활용inherit클래스의 상속을 흉내내려면 어떤 함수의 prototype 에 들어갈 객체가 원하는 proto를 갖고 있으면 된다.하지만 자바스크립트에서 proto를 설정하는 유일한 방법은 new 연산자 이다. 자식이 될 함수의 prototype에 new를 통해 부모 함수의 객체를 생성 할당한다. copyproto체인을 포기하고 인터페이스의 모든 구조를 복사한다. 12345678910111213function Imp1() &#123;&#125;function Imp2() &#123;&#125;function Concreate() &#123; // 한 개 밖에 안되잔아? Concreate.prototype = new Imp1(); 그렇다. 일자전승! 그냥은 한게 밖에 안된다. 유일한 방법은 Imp1 과 Imp2 의 키를 Concreate 에 복사하는 것이다. fro(key in Imp1) Concreate.prototpye[key] = Imp1[key]; fro(key in Imp2) Concreate.prototpye[key] = Imp2[key];&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://eggplantwo.github.io/categories/javascript/"}],"tags":[]},{"title":"웹팩이란","slug":"웹팩이란","date":"2017-04-21T07:02:31.000Z","updated":"2017-04-21T07:07:27.319Z","comments":true,"path":"2017/04/21/웹팩이란/","link":"","permalink":"http://eggplantwo.github.io/2017/04/21/웹팩이란/","excerpt":"","text":"웹팩이란?최근의 웹 개발이 복잡한 자바스크립트와 대규모 의존성 트리가 포함된 다양한 기능을 갖춘 웹 어플리케이션으로 발전되면서복잡성에 대응하기 위한 방법을 고안하게 되었다. 한 프로그램을 여러 파일의 파일로 분할하고 구성할 수 있는 자바스크립트 모듈 향후 자바스크립트에서 제공될 기능을 미리 이용할 수 있게 해주는 자바스크립트 전처리기(pre-processor)와 자바스크립트로 컴파일되는 언어(예:CoffeeScript) 이러한 방법은 아주 유용하지만 파일을 브라우저가 이해할 수 있도록 번들로 묶고, 변환(트랜스파일 및 컴파일)하는 추가 단계를 거처야 이용할 수 있다. 웹팩은 프로젝트의 구조를 분석하고 자바스크립트 모듈을 비롯한 애셋을 찾은 다음 이를 브라우저에서 이용할 수 있는 번들로 묶고 패킬하는 모듈 번들러(module bundler) 이다. 그런트나 걸프와 같은 빌드 도구와의 차이점 웹팩은 빌드 툴이 아니므로 그런트(Grunt)나 걸프(Gulp) 등의 태스크 러너나 빌드 시스템과는 다르지만 이러한 툴을 대체하면서 장점을 제공해 준다. 그런트나 걸프 같은 빌드 툴은 정의한 경로에서 구성과 일치하는 파일을 찾는다. 따라서 구성 파일에서 이러한 파일을 변환, 조합 및 축소(minify)하는 작업이나 단계를 지정해야 한다. 자바스크립트 ES6모듈을 번들로 묶는 워크 플로우. 소스폴더(자바스크립트 ES6) 폴더에서 모든 파일을 읽음 첫번재 작업 (플러그인을 통한 처리) JS로 트랜스 파일 파일을 저장하거나 다음 작업으로 전달 JS 모듈을 번들로 묶음 파일 저장 번들로 묶은 자바스크립트 (bundle.js) 이와 달리 웹팩은 프로젝트 전체를 한 단위로 분석한다.즉, 지정한 메인 파일에서 시작해 자바스크립트의 require와 import 문을 참고해 프로젝트의 모든 의존성을 조사하고로더를 이용해 처리한 후 번들로 묶은 자바스크립트 파일을 생성한다. 메인파일(entry) 에서 시작 entry와 관련된 의존성 검사 및 로더를 이용해 처리 번들로 묶은 자바스크립트 생성. bundle.js 시작하기npm을 이용해 전역으로 설치하거나 ( npm install -g webpack ),특정 트로젝트의 의존성으로 설치 ( npm install –save-dev webpack ) 한다. 예제 프로젝트먼저 새로운 프로젝트 폴더를 생성하고 package.json 파일을 만든다.package.json 파일은 프로젝트에 대한 다양한 정보를 포함하는 표준 npm 매니페스트 이다.개발자가 의존성을 지정하고 스크립트 태스크를 정의할 수 있게 해준다. package.json 파일 생성 방법npm init 입력 init은 프로젝트에 대한 기본 질문들을 표시하고 최종적으로 package.json을 생성해 준다.(잘 모르겠다는 그냥 enter를 계속 눌러도 상관없음, 수동으로 만들거나 에디터에서 수정이 가능하다.) 폴더 구조project – node_modules – app main.js – public index.htmlpackage.json 구성 파일 정의웹팩은 다양한 고급 옵션을 제공하며, 로드한 모듈에 로더와 플러그인을 이용해 변환을 적용할 수 있게 해준다.명령줄에서 모든 옵션을 지정하고 웹팩을 실행하는 것도 가능하지만 이 방법은 추천하지 않는다. webpack.config.js 파일 만들어 보기123456789module.exports = &#123; devtool: 'source-map' entry : __dirname + \"/app/main.js\", output : &#123; path : __dirname + \"/public\", filename : \"bundle.js\" &#125;&#125;//__dirname : 현재 실행 중인 스크립트가 있는 디렉터리 이름을 포함하는 node.js 전역 변수이다. // shell~ webpack_proj &gt; node_modules/.bin/webpack 테스크로 바로가기 추가node_modules/.bin/webpack 과 같은 긴 명령은 입력하기 번거롭고 잘못 입력할 가능성도 있다.npm을 태스크 러너로 사용해 npm start와 같은 명령으로 대체할 수 있다. package.json 파일 안에 scripts 섹션을 추가 하면 된다.12345678910&#123; \"name\" : \"\", \"version\" : \"1.0.0\", \"description\" : \"Sample webpack project\", \"scripts\" : &#123; \"start\" : \"node_modules/.bin/webpack\" &#125;, ....&#125; 소스맵 생성.패키지의 모든 자바스크립트 모듈을 하나(또는 소수)의 번들 파일로 만들어 브라우저에서 이용하면 많은 장점이 있지만,브라우저에서 디버깅할 때 원래 어떤 파일의 어떤 부분에서 문제가 생겼는지 찾기가 어렵다는 단점이 있다.이 문제를 해결하기 위해 웹팩의 소스맵(source map)을 이용할 수 있다. 소스맵 은 번들 파일 내의 코드를 원래 소스 파일로 연결함으로써 브라우저에서 코드를 읽고 디버그하기 쉽게 만들어 준다.12345678module.exports = &#123; devtool: 'source-map' entry : __dirname + \"/app/main.js\", output : &#123; path : __dirname + \"/public\", filename : \"bundle.js\" &#125;&#125; 웹팩 개발 서버로컬 개발을 위해 옵션으로 제공하는 서버.웹팩 개발 서버는 정적 파일을 제공하며, 웹팩 구성에 따라 애셋을 빌드한 후 메모리에 저장했다가,개발자가 소스 파일을 수정하면 자동으로 브라우저를 새로 고치는 간단한 node.js 익스프레스 앱이다.( 웹팩 개발 서버는 별도의 npm 모듈이므로 의존성으로 설치해야 사용이 가능하다. npm install –save-dev webpack-dev-server) devserver 설정 devserver 설정 설명 contentBase 기본적으로 웹팩 개발 서버는 프로젝트 루트에 있는 파일을 서비스한다. 다른 폴더(예:예제 프로젝트의 “public” 폴더)의 파일을 서비스하려면 이 설정으로 특정 콘텐츠 기반(content base)을 구성해야 한다. port 사용할 포트를 지정하여, 생략할 경우 기본값은 “8080” 이다. inline “true”로 설정하면 작은 클라이언트 엔트리를 번들에 삽입해 페이지가 변경되면 새로 고친다. colors 서버가 터미널에 출력하는 내용에 색상을 지정한다. historyApiFallback html5 히스토리 api를 이용하는 단일 페이지 어플리케이션을 개발할 때 유용한 옵션으로서 “true”로 설정하면 기존 애셋과 매핑되지 안을 웹팩 개발 서버에 대한 모든 요청이 곧바로 “/“ 루트로 (index.html)로 라우팅 된다. 1234567891011121314module.exports = &#123; devtool: 'source-map' entry : __dirname + \"/app/main.js\", output : &#123; path : __dirname + \"/public\", filename : \"bundle.js\" &#125;, devServer: &#123; contentBase : \"./public\", colors : true, historyApiFallback : true, inline: true &#125;&#125; “npm start” 를 호출해 서버를 실행할 수 있도록 프로젝트의 package.json 파일에서 “scripts” 섹션을 편집할 수 있다.1234567891011&#123; \"name\" : \"\", \"version\" : \"1.0.0\", \"description\" : \"Sample webpack project\", \"scripts\" : &#123; \"start\" : \"node_modules/.bin/webpack-dev-server --progress\" &#125;, ....&#125;// --progress 매개변수는 명령줄에서만 사용할 수 있으며, 빌드 단계 중에 터미널에 진행 상황을 표시한다. 로더로더를 이용하면 외부 스크립트와 도구를 통해 소스 파일을 전처리하고 다양한 변경과 변환을 적용할 수 있다. json 파일을 일반 자바스크립트 구문 분석 es6등의 신규 문법 코드를 현재 브라우저가 이해할 수 있는 일반 자바스크립트로 변환 리엑트의 jsx를 일반 자바스크립트로 변환 로더는 별도로 설치해야 하며 webpack.config.js의 “modules” 키에서 구성한다. - test : 로더에서 처리하기 위해 일치해야 하는 파일 확장자를 비교하는 정규식 (필수) - loader : 로더의 이름(필수) - include/exclude : 로더가 명시적으로 추가하거나 무시할 폴더와 파일을 수동으로 지정하는 옵션 설정. - query : 로더에 추가 옵션을 전달하는 데 이용되는 쿼리 설정. npm install –save json-loader 123456789101112131415161718module.exports = &#123; devtool: 'source-map' entry : __dirname + \"/app/main.js\", output : &#123; path : __dirname + \"/public\", filename : \"bundle.js\" &#125;, module : &#123; loaders : [ &#123; test : /\\.jsx?$/, loader : 'json' &#125; ] &#125; ...&#125; 바벨자바스크립트 컴파일과 도구 지원을 위한 플랫폼 이다. 아직 일부 브라우저에서 지원되지 않은 자바스크립트의 다음 버전(es6, es7등)을 이용할 수 있게 해준다. 리액트의 jsx와 같은 자바스크립트 구문 확장을 이용할 수 있게 해준다. 바벨은 독립 실행형 도구지만 로더로 이용할 수 있으며, 웹팩과 잘 어울린다. 설치와 구성.바벨은 모듈형 구조를 띠며, 다양한 npm 모듈로 배포된다. 핵심 기능은 “babelcore” npm 패키지로 제공되며,웹팩과의 통합은 “babel-loader” npm 패키지로 제공된다.자주 사용되는 패키지로는 babel-preset-es2015 : es6 컴파일용 babel-preset-react : react jsx 지원 다른 웹팩 로더와 마찬가지로 바벨도 웹팩 구성 파일의 모듈 섹션에서 구성할 수 있다.1234567891011121314151617181920module.exports = &#123; ... module : &#123; loaders : [ &#123; test : /\\.json$/, loader : 'json' &#125;, &#123; test : /\\.jsx?$/, exclude : /node_modules/, loader : 'babel', query : &#123; presets : ['es2015', 'react'] &#125; &#125; ] &#125; ...&#125; 바벨 구성 파일바벨을 webpack.config.js에서","categories":[{"name":"javascript","slug":"javascript","permalink":"http://eggplantwo.github.io/categories/javascript/"}],"tags":[]},{"title":"디자인패턴","slug":"디자인패턴","date":"2017-04-21T07:01:31.000Z","updated":"2017-04-21T07:07:29.972Z","comments":true,"path":"2017/04/21/디자인패턴/","link":"","permalink":"http://eggplantwo.github.io/2017/04/21/디자인패턴/","excerpt":"","text":"디자인 패턴싱글톤(Singleton)123456789101112131415161718192021function Universe() &#123; // 캐싱된 인스터스 var instance; // 생성자를 재작성한다. Universe = function Universe() &#123; return instance; &#125;; // prototype 프로퍼티를 변경한다. Universe.prototype = this; // instance instance = new Universe(); // 생성자 포인터를 재지정 한다. instance.constructor = Universe; instance.start_time = 0; instance.bang = 'Big';&#125; 팩터리(Factory)팩터리 패턴의 목적은 객체들을 생성하는 것이다.팩터리 패턴은 흔히 클래스 내부에서 또는 클래스의 스태틱 메서드로 구현되며, 다음과 같은 목적으로 사용된다. 비슷한 객체를 생성하는 반복 작업을 수행한다. 팩터리 패턴의 사용자가 컴파일 타임에 구체적인 타입(클래스)을 모르고도 객체를 생성할 수 있게 해준다. 팩터리 메서드(또는 클래스)로 만들어진 객체들은 의도적으로 동일한 부모 객체를 상속한다.즉, 이들은 특화된 기능을 구현하는 구체적인 서브 클래스들이다.어떤 경우에는 공통의 부모 클래스가 팩터리 메서드를 갖고 있기도 한다. CarMaker 생성자 : 공통의 부모 CarMaker.factory() : car 객체들을 생성하는 스태틱 메서드 CarMaker.Compact, CarMaker.SUV, CarMaker.Convertible : CarMaker 를 상속하는 특화된 생성자.이 모두는 부모의 스태틱 프로터티로 정의되어 전역 네임스페이스를 깨끗이 유지하며, 필요할 때 쉽게 찾을 수 있다. 사용예 123456var corolla = CarMaker.factory('Compact');var solstice = CarMaker.factory('Convertible');var cherokee = CarMaker.factory('SUV');corolla.drive(); // Vroom, I have 4 doors;solstice.drive(); // Vroom, I have 2 doors;cherokee.drive(); // Vroom, I have 17 doors; 이 부분을 눈여겨 보자var corolla = CarMaker.factory(‘Compact’);이 부분이 아마도 팩터리 패턴에서 가장 특징적인 부분일 것이다.이 메서드는 런타임시 문자열로 타입을 받아 해당 타입의 객체를 생성하고 반환한다.new와 함께 생성자를 사용하지 않고, 객체 리터럴도 보이지 않는다. 팩터리 패턴 구현 예1234567891011121314151617181920212223242526272829303132333435363738394041function CarMaker()&#123;&#125;CarMaker.prototype.dirve = function() &#123; return 'Vroom, I have ' + this.doors + ' doors';&#125;CarMaker.factory = function (type) &#123; var constr = type, newcar; // 생성자가 존재하지 않으면 에러 발생 if ( typeof CarMaker[constr] !== 'function' ) &#123; throw &#123; name : 'Error', message : constr + ' doesn`t exist'; &#125; &#125; // 생성자의 존재를 확인했으므로 부모를 상속한다. // 상속은 단 한번만 실행된다. if ( typeof CarMaker[constr].prototype.drive !== 'function' ) &#123; CarMaker[constr].prototype = new CarMaker(); &#125; // 새로운 인스톤스 생성 newcar = new CarMaker[constr](); // 다른 메서드 호출이 필요하면 여기서 실핼한 후, 인스턴스를 반환한다. return newcar;&#125;// 구체화CarMaker.Compact = function() &#123; this.door = 4;&#125;CarMaker.Convertible = function() &#123; this.door = 2;&#125;CarMaker.SUV = function() &#123; this.door = 24;&#125; 반복자(Iterator)데이터가 저장된 내부구조는 복잡하더라도 개별 요소에 쉽게 접근할 방법이 필요하다.사용자는 데이터 구조를 알 필요가 없이, 개별 요소로 원하는 작업을 할수만 있으면 된다. 장식자(Decorator)런타임시 부가적인 기능을 객체에 동적으로 추가할 수 있다.특징은 기대되는 행위를 사용자화하거나 설정할 수 있다는 것이다.처음에는 기본적인 몇 가지 기능을 가지는 평범한 객체로 시작한다. 그런다음 사용 가능한 장식자들의 풀(poll)에 원하는 것을 골라 객체에 기능을 덧 붙여간다. 12345var sale = new Sale(100);sale = sale.decorate('fedtax');sale = sale.decorate('quebec');sale = sale.decorate('money');sale.getPrice(); getPrice()를 호출하면 money 장식자의 동일한 메서드를 호출한 셈이된다. 그러나 각각의 꾸며진 메서드는 우선 부모의 메서드를 호출하기 때문에,money의 getPrice()는 quebec의 getPrice()를 호출하고, 다시 fedtax의 getPrice를 호출하는 식으로 차례대로 거슬러 올라 간다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677function Sale(price) &#123; this.price = price || 100;&#125;Sale.prototype.getPrice = function() &#123; return this.price;&#125;// 장식자 객체들은 생성자 프로퍼티 Sale.decorators의 프로퍼티로 구현된다.Sale.decorators = &#123;&#125;Sale.decorators.fedtax = &#123; getPrice : function() &#123; var price = this.uber.getPrice(); price += price * 5 / 100; return price; &#125;&#125;Sale.decorators.fedtax = &#123; getPrice : function() &#123; var price = this.uber.getPrice(); price += price * 5 / 100; return price; &#125;&#125;Sale.decorators.quebec = &#123; getPrice : function() &#123; var price = this.uber.getPrice(); price += price * 7.5 / 100; return price; &#125;&#125;Sale.decorators.money = &#123; getPrice : function() &#123; return '$' + this.uber.getPrice().toFixed(2); &#125;&#125;Sale.decorators.cdn = &#123; getPrice : function() &#123; return 'CDN$' + this.uber.getPrice().toFixed(2); &#125;&#125;// 모든 조각들을 짜맞추는 마법의 decorate() 메서드.sale = sale.decorate('fedtax');// 임시생성자 패턴을 이용해 상속을 구현하고, 자식 객체가 부모 객체에 접근 할 수 있도록 newobj에 uber 프로퍼티 지정.Sale.prototype.decorate = function(decorator) &#123; var F = function() &#123;&#125;, overrides = this.constructor.decorators[decorator], i, newobj; F.prototype = this; newobj = new F(); newobj.uber = F.prototpye; for ( i in overrides ) &#123; if ( overrides.hasOwnProperty(i) ) &#123; newobj[i] = overrides[i]; &#125; &#125; return newobj;&#125;// 다름 방식 (큐에 에 답아서 ..)Sale.prototype.decorate = function(decorator) &#123; this.decorators_list.push(decorator);&#125;Sale.prototype.getPrice = function() &#123; var price = this.price, i, max = this.decorators_list.length, name; for ( i = 0; i &lt; max; i++ ) &#123; name = this.decorators_list[i]; price = Sale.decorators[name].getPrice(price); &#125;&#125; 전략데이터 유효성 검사 예제 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586var data = &#123; first_name : 'super', last_name : 'man', age : 'unknow', username : 'o_o'&#125;validator.config = &#123; first_name : 'isNonEmpty', age : 'isNumber', username : 'isAlphaNum' &#125;validator.validate(data);if ( validator.hasErrors() ) &#123; console.log(validator.message.join(\"\\n\"));&#125;// 값을 가지는지 확인validator.types.isNonEmpty = &#123; validate : function (value) &#123; return value !==''; &#125;, instructions : '이 값은 필수 입니다.'&#125;;// 숫자 값인지 확인한다.validator.type.isNumber = &#123; validate : function(value) &#123; return !isNan(value); &#125;, instructions : '숫자만 사용할 수 있습니다.'&#125;// 값이 문자와 숫자로만 이루어졌는지 확인한다.validator.types.isAlphaNum = &#123; validate : function(value) &#123; return !/[^a-z0-9]/i.test(value); &#125;, instructions : '특수 문자를 제외한 글자와 숫자만 사용할 수 있습니다.'&#125;var validator = &#123; // 사용할 수 있는 모든 검사 방법들 types : &#123;&#125;, // 검사 메세지들 messages : [], // 유효성 검사 설정 config : &#123;&#125;, // 인터페이스 메서드 validate : function(data) &#123; var i, msg, type, checker, result_ok; this.messages = []; for ( i in data ) &#123; if ( data.hasOwnProperty(i) ) &#123; type = this.config[i]; checker = this.types[type]; if ( !type ) &#123; continue; //설정값이 없을때 건너뜀 &#125; // 설정이 존재하지 않거나 오류 발생시 if ( !checker ) &#123; throw &#123; name : 'ValidationError', message : type + '값을 처리할 유효성 검사기가 존재하지 않습니다.' &#125;; &#125; result_ok = checker.validate(data[i]); if ( !result_ok ) &#123; msg = ㅑ + '값이 유효하지 않습니다.' + checker.instructions; &#125; &#125; &#125; return this.Errors(); &#125;, hasErrors : function() &#123; return this.messages.length !== 0; &#125;&#125; 퍼사드(Facade)프록시(Proxy)중재자(Mediator)이 패턴은 결합도를 낮추고 유지보수를 쉽게 개선하여 완화시킬수 있다.객체들은 직접 통신하지 않고 중재자를거쳐 중재자에게 알리고, 중재자는 이 변경사항을 알아야하는 객체들에게 알린다. 123456789101112131415161718192021222324252627282930313233function Player(name) &#123; this.points = 0; this.name = name;&#125;Player.prototype.play = function() &#123; this.points += 1; mediator.played();&#125;var scoreboard = &#123; // 점수를 표시할 HTML 엘리먼트 element : document.getElementById('results'), // 점수 표시를 갱신한다. update : function (score) &#123; var i, msg = ''; for ( i in score ) &#123; if ( score.hasOwnProperty(i) ) &#123; msg += '&lt;p&gt;&lt;srtong&gt;'+i+'&lt;/srtong&gt;'; msg += scord[i]; msg += '&lt;/p&gt;' &#125; &#125; this.element.innerHTML = msg; &#125;&#125;var mediator = &#123; ...&#125; 감시자(Observer)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var publisher = &#123; subscribers : &#123; any : [] // '이벤트 타입 : 구독자의 배열' &#125;, subscribe : function( fn, type ) &#123; type = type || 'any'; if ( typeof this.subscribers[type] === 'undefiend' ) &#123; this.subscribers[type] = []; &#125; this.subscribers[type].push(fn); &#125;, unsubscribe : function( fn, type ) &#123; this.visitSubscribers('unsubscribe', fn, type); &#125;, publish : function(publication, type) &#123; this.visitSubscribers('publish', publication, type); &#125;, visitSubscribers : function(action, arg, type) &#123; var pubtype = type || 'any', subscribers = this.subscribers[pubtype], i, max = subscribers.length; for ( i = 0; i &lt; max; i++ ) &#123; if ( action === 'publish' ) &#123; subscribers[i](arg); &#125; else &#123; if ( subscribers[i] === arg ) &#123; subscribers.splice(i, 1) &#125; &#125; &#125; &#125;&#125;// 객체를 받아 발행자 객체로 바꿔준다.// 단순히 해당 객체에 범용 발행자 메서드들을 복사해 넣는다.(deep copy)function makePublisher(o) &#123; var i; for ( i in publisher ) &#123; if ( publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] === 'function' ) &#123; o[i] = publisher[i]; &#125; &#125; o.subscribers = &#123;any : []&#125;;&#125;var paper = &#123; daily : function() &#123; this.publish('big news today'); &#125;, monthly : function() &#123; this.publish('interesting analysis', 'monthly'); &#125;&#125;// paper을 발행자로 만든다.makePublisher(paper)// 구독자 joevar joe = &#123; drinkCoffee : function (paper) &#123; console.log(paper + '를 읽었습니다.'); &#125;, sundayPreNap : function (monthly) &#123; console.log('잠들기 전에' + monthly + '를 읽고 있습니다.'); &#125;&#125;paper의 구독자 목록에 joe를 추가paper.subscrib(joe.drinkCoffee);paper.subscrib(joe.sundayPreNap, 'monthly');// 이벤트 발생 실행paper.daily();paper.daily();paper.daily();paper.monthly(); paper 객체 내에서 joe를 하드코딩하지 않았고 , joe 객체 안에서도 역시 paper 객체를 하드코딩 하지 않았다는 점에서 훌륭하다.모든 내용을 알고 있는 중재자 객체가 존재하지도 않는다.객체들은 느슨하게 결합되었고, 이 객체들을 전혀 수정하지 않고 paper에 수많은 구독자를 추가할 수 있다.구독 해지도 언제든지 가능하다. 예제 2 키 누르기```jsvar publisher = { subscribers : { any : [] // ‘이벤트 타입 : 구독자의 배열’ }, on : function( type, fn, context ) { type = type || ‘any’; fn = typeof fn === ‘function’ ? fn : context[fn]; if ( typeof this.subscribers[type] == &apos;undefined&apos; ) { this.subscribers[type] = []; } this.subscribers[type].push({ fn : fn, context : context || this }); }, remove : function( type, fn, context ) { this.visitSubscribers(&apos;unsubscribe&apos;, type, fn, context); }, fire : function( type, publication ) { this.visitSubscribers(&apos;publish&apos;, type, publication); }, visitSubscribers : function(action, type, arg, context) { var pubtype = type || &apos;any&apos;, subscribers = this.subscribers[pubtype], i, max = subscribers.length; for ( i = 0; i &lt; max; i++ ) { if ( action === &apos;publish&apos; ) { subscribers[i].fn.call(subscribers[i].context, arg); } else { if ( subscribers[i].fn === arg &amp;&amp; subscribers[i].context === context) { subscribers.splice(i, 1) } } } } } function Player(name, key) { this.points = 0; this.name = name; this.key = key; this.fire(‘newplayer’, this);} Player.prototype.play = function() { this.points += 1; this.fire(‘play’, this);} var game = { keys : {} addPlayer : function(player) { var key = player.key.toString().charCodeAt(0); this.keys[key] = player; }, handleKeypress : function(e) { e = e || window.event; if ( game.keys[e.which] ) { game.keys[e.which].play(); } }, handlePlay : function(player) { var i, players = this.keys, score = {}; for ( i in players ) { if ( players.hasOwnProperty(i) ) { score[players[i].name] = players[i].points; } } this.fire(‘scorechange’, score); }} makePublisher(Player.prototype);makePublisher(game); /** game 객체는 play와 newplayer 이벤트 브라우저의 keypress 이벤트를 구독한다. scoreboard 객체는 scorechange 이벤트를 구독한다.*/ Player.prototype.on(‘newplayer’, ‘addPlayer’, game);Player.prototype.on(‘newplayer’, ‘handlePlayer’, game);game.on(‘scorechange’, scoreboard.update, scoreboard);window.onkeypress = game.handleKeypress; // TEST CODE —————– function makePublisher(o) { var i; for ( i in publisher ) { if ( publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] === ‘function’ ) { o[i] = publisher[i]; } } o.subscribers = {any : []};}var scoreboard = { // 점수를 표시할 HTML 엘리먼트 element : document.getElementById(‘results’), // 점수 표시를 갱신한다. update : function (score) { console.log(&apos;scoreboard.update&apos;); // var i, msg = ‘’;// for ( i in score ) {// if ( score.hasOwnProperty(i) ) {// msg += ‘‘+i+’‘;// msg += scord[i];// msg += ‘‘// }// }// this.element.innerHTML = msg; }} var publisher = { subscribers : { any : [] // ‘이벤트 타입 : 구독자의 배열’ }, on : function( type, fn, context ) { type = type || ‘any’; fn = typeof fn === ‘function’ ? fn : context[fn]; if ( typeof this.subscribers[type] == &apos;undefined&apos; ) { this.subscribers[type] = []; } this.subscribers[type].push({ fn : fn, context : context || this }); }, remove : function( type, fn, context ) { this.visitSubscribers(&apos;unsubscribe&apos;, type, fn, context); }, fire : function( type, publication ) { this.visitSubscribers(&apos;publish&apos;, type, publication); }, visitSubscribers : function(action, type, arg, context) { //console.log(action, type, arg); var pubtype = type || &apos;any&apos;, subscribers = this.subscribers[pubtype], i, max = subscribers.length; for ( i = 0; i &lt; max; i++ ) { if ( action === &apos;publish&apos; ) { subscribers[i].fn.call(subscribers[i].context, arg); } else { if ( subscribers[i].fn === arg &amp;&amp; subscribers[i].context === context) { subscribers.splice(i, 1) } } } } } function Player(name, key) { this.points = 0; this.name = name; this.key = key; this.fire(‘newplayer’, this);} Player.prototype.play = function() { this.points += 1; this.fire(‘newplayer’, this);} var game = { keys : {}, addPlayer : function(player) { console.log(‘add player’);// var key = player.key.toString().charCodeAt(0);// this.keys[key] = player; }, handleKeypress : function(e) { e = e || window.event; if ( game.keys[e.which] ) { game.keys[e.which].play(); } }, handlePlay : function(player) { var i, players = this.keys, score = {}; for ( i in players ) { if ( players.hasOwnProperty(i) ) { score[players[i].name] = players[i].points; } } this.fire(‘scorechange’, score); }} makePublisher(Player.prototype);makePublisher(game); /** game 객체는 play와 newplayer 이벤트 브라우저의 keypress 이벤트를 구독한다. scoreboard 객체는 scorechange 이벤트를 구독한다.*/ Player.prototype.on(‘newplayer’, ‘addPlayer’, game);Player.prototype.on(‘newplayer’, ‘handlePlay’, game);game.on(‘scorechange’, scoreboard.update, scoreboard);","categories":[{"name":"javascript","slug":"javascript","permalink":"http://eggplantwo.github.io/categories/javascript/"}],"tags":[]},{"title":"객체생성패턴","slug":"객체생성패턴","date":"2017-04-21T07:00:31.000Z","updated":"2017-04-21T07:07:32.226Z","comments":true,"path":"2017/04/21/객체생성패턴/","link":"","permalink":"http://eggplantwo.github.io/2017/04/21/객체생성패턴/","excerpt":"","text":"객체 생성 패턴네임스페이스 패턴비공개 프로퍼티와 메서드비공개 멤버와 특권 멤버모듈 패턴다음의 패턴들 여러개를 조합. 네임 스페이스 패턴 즉시 실행 함수 비공개 멤버와 특권 멤버 의존 관계 선언 12 모듈 노출 패턴 … 생성자를 생성하는 모듈 … 모듈에 전역 변수 가져오기 … 샌드박스 패턴.네임스페이스 패턴의 단점을 보완 전역 객체가 단 하나의 전역변수에 의존한다.따라서 동일한 애플리케이션이나 라이브러리의 두 가지 버전을 한 페이지에서 실행시키는 것이 불가능 하다.전역변수 명이 모두 하나이기 때문. MYAPP.utilities.array 와 같이 점으로 연결된 긴 이름을 써야 하고 런타임에는 탐색 작업을 거쳐야 한다. 전역 생성자네임스페이스 패턴에서는 전역 객체가 하나다. 샌드박스 패턴의 유일한 전역은 생성자다.생성자에 콜백 함수를 전달해 해당 코드를 샌드박스 내부 환경으로 격리시킨다. 123new Sandbox( function(box) &#123; // coding...&#125;); box 객체는 네임스페이스 패턴에서 MYAPP과 같은 것이다. 코드가 동작하는데 필요한 모든 라이브러리 기능이 여기에 들어간다. 패턴에 추가해 보기 new 강제한다. new를 쓰지않아도 자동으로 처리 Sandbox() 생성자가 선택적인 인자를 하나 이상 받을 수 있게 한다. 1234567891011121314151617181920212223242526272829303132Sandbox( ['ajax', 'event'], function(box) ) &#123; // coding...&#125;);Sandbox( 'ajax', 'event', function(box) ) &#123; // coding...&#125;);// 모든 모듈을 사용한다는 의미로 '*'이나, 생략도 생각해 볼 수 있다.Sandbox( '*', function(box) ) &#123; // coding...&#125;);Sandbox( function(box) ) &#123; // coding...&#125;);// 샌드박스 객체의 인스턴스를 여러 개 만드는 예제.Sandbox( 'dom', 'event', function(box) ) &#123; // dom과 event를 가지고 작업하는 코드 Sandbox( 'ajax', function(box) ) &#123; // 샌드박스된 box 객체를 또 하나 만든다. // 이 'box' 객체는 바깥쪽 함수의 'box' 객체와는 다르다. // ... // ajax를 사용하는 작업 완료 &#125;); // ajax 모듈의 흔적이 없어진.&#125;); 샌드박스 패턴을 사용하면 콜백 함수로 코드를 감싸기 때문에 전역 네임스페이스를 보호할 수 있다. 샌드박스 패턴 구현12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** 생성자 구현 **/function Sandbox() &#123; var args = Array.prototype.slice.call(arguments), // 마지막 인자는 콜백함수 callback = args.pop(), modules = ( args[0] &amp;&amp; typeof args[0] === 'string' ? args : args[0] ), i; // 함수가 생성자로 호출되도록 보장한다. if ( !(this instanceof Sandbox) ) &#123; return new Sandbox(modules, callback); &#125; // this에 필요한 프로퍼티들을 추가 한다. this.a = 1; this.b = 2; // 코어 this 객체에 모듈을 추가한다. // 모듈이 없거나 * 이면 사용 가능한 모든 모듈을 사용한다는 의미. if ( !modules || modules === '*' || modules[0] === '*' ) &#123; modules = []; console.log(Sandbox.modules); for ( i in Sandbox.modules ) &#123; console.log(1); if ( Sandbox.modules.hasOwnProperty(i) ) &#123; console.log(2); modules.push(i); &#125; &#125; &#125; // 필요한 모듈을 초기화 한다. for ( i = 0; i &lt; modules.length; i += 1 ) &#123; Sandbox.modules[modules[i]](this); &#125; // 콜백함수 호출 callback(this); Sandbox.prototype = &#123; name : 'MyApp', version : '1.0', getName : function() &#123; return this.name; &#125; &#125; &#125;/** 모듈추가 **/Sandbox.modules = &#123;&#125;Sandbox.modules.dom = function(box) &#123; box.getElement = function()&#123; console.log('getElement'); &#125;; box.getStyle = function()&#123; console.log('getStyle'); &#125;; box.foo = 'bar';&#125;Sandbox.modules.event = function(box) &#123; // 필요에 따라 다음과 같이 Sandbox 프로토타입에 접근할 수 있다. // box.constructor.prototype.m = 'mmm'; box.attachEvent = function()&#123; console.log('attachEvent'); &#125;; box.detachEvent = function()&#123; console.log('detachEvent'); &#125;;&#125;Sandbox.modules.ajax = function(box) &#123; box.makeRequest = function()&#123; console.log('makeRequest'); &#125;; box.getResponse = function()&#123; console.log('getResponse'); &#125;;&#125;Sandbox(['ajax', 'event'], function(box) &#123; box.attachEvent(); box.makeRequest();&#125;); 스태틱 맴버공개 스태틱 맴버 1234567891011121314151617// 생성자var Gadget = function() &#123;&#125;;// 스태틱 메서드Gadget.isShiny = function() &#123; return 'you bet';&#125;// 프로토타입에 일반적인 함수를 추가한다.Gadget.prototype.setPrice = function(price) &#123; this.price = price;&#125;;// 프로토타입에 일반적인 메서드를 추가한다.Gadget.prototype.isShiny = function() &#123; return Gadget.isShiny.call(this);&#125; 비공개 스태틱 맴버 동일한 생성자 함수로 생성된 객체들이 공유하는 멤버. 생성자 외부에서는 접금할 수 없다. 1234567891011121314151617181920212223242526272829303132var Gadget = (function() &#123; var counter = 0; return function() &#123; console.log(++counter); &#125;&#125;());// getLastId() 추가var Gadget = (function() &#123; var counter = 0, NewGadget; NewGadget = function() &#123; counter += 1; &#125;; NewGadget.prototype.getLastId = function() &#123; return counter; &#125;; // 생성자를 덮어 쓴다. return NewGadget;&#125;());var a = new Gadget();a.getLastId();var b = new Gadget();b.getLastId(); 객체 상수 ( es6 const )체이닝 패턴method() 메서드123456if ( typeof Function.prototype.method !== 'function' ) &#123; Function.prototype.method = function (name, implementation) &#123; this.prototype[name] = implementation; return this; &#125;;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://eggplantwo.github.io/categories/javascript/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-04-21T00:34:51.847Z","updated":"2017-04-21T00:34:51.849Z","comments":true,"path":"2017/04/21/hello-world/","link":"","permalink":"http://eggplantwo.github.io/2017/04/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"자주 사용 되는 5가지 배열 메소드","slug":"JS배열 메소드 5개","date":"2017-04-21T00:20:04.000Z","updated":"2017-04-21T07:07:05.965Z","comments":true,"path":"2017/04/21/JS배열 메소드 5개/","link":"","permalink":"http://eggplantwo.github.io/2017/04/21/JS배열 메소드 5개/","excerpt":"","text":"자주 사용 되는 5가지 배열 메소드indexOf12345678910// 미사용var isExist =false;for( var i = 0; max = array.length; i += 1 ) &#123; if ( array[i] === \"value\" )&#123; isExist = true; &#125;&#125;// 사용var isExist = (array.indexOf('value')!== -1 ) filterJSON 오브젝트로 이루어진 배열중에 특정 값만 filter 12345678910var arr = [ &#123;\"name\":\"apple\", \"count\": 2&#125;, &#123;\"name\":\"orange\", \"count\": 5&#125;, &#123;\"name\":\"pear\", \"count\": 3&#125;, &#123;\"name\":\"orange\", \"count\": 16&#125;]; var newArr = arr.filter(function(item)&#123; return item.name === \"orange\";&#125;); console.log(\"Filter results:\", newArr); forEachfor루프가 성능상 더 좋지만 일반적인 사용에는 큰차이가 없으므로 사용해도 좋다. 123456var arr = [1, 2, 3, 4, 5];arr.forEach( (v, i) =&gt; &#123; if ( v === 3 ) &#123; console.log( v, i ); //3 2 &#125;&#125;); mapmap이 forEach 보다 성능이 미세하게 좋다.map은 루프에서 return 할 수 있다. 123var a = [1, 2, 3, 4, 5];var b = a.forEach( (v, i) =&gt; v + 1 ); // undefinedvar c = a.map( (v, i) =&gt; v + 1 ); // [2, 3, 4, 5, 6] reduce구문arr.reduce(callback[, initialValue]) 123[0, 1, 2, 3, 4].reduce(function(previousValue, currentValue, currentIndex, array) &#123; return previousValue + currentValue;&#125;, 10); // 초기 prev값 지정(생략시 0번 index) 배열 값 더하기1234var total = [0, 1, 2, 3].reduce(function(a, b) &#123; return a + b;&#125;);// total == 6 2차원 배열 1차원으로 만들기1234var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123; return a.concat(b);&#125;, []);// flattened is [0, 1, 2, 3, 4, 5]","categories":[{"name":"javascript","slug":"javascript","permalink":"http://eggplantwo.github.io/categories/javascript/"}],"tags":[]}]}